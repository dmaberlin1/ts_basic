/*****************************************ПРОДВИНУТЫЕ ТИПЫ**************************************
 /*****************************************ПРОДВИНУТЫЕ ТИПЫ**************************************
 /*****************************************ПРОДВИНУТЫЕ ТИПЫ**************************************

 //********************************************************UNION*************************************
 //********************************************************UNION*************************************/

// const arr=['log',1]
// //сужение типов, будем пользоваться достаточно часто
// function logId(id:string|number|boolean) {
//     if(typeof id==='string') console.log(id.toUpperCase())
//     if(typeof id==='number') console.log(id.toFixed(2))
//     else console.log(id)
// }
// logId(1)
// logId('log')
// logId(true)
//
// //таким образом в юнион типах мы можем исключить то что является массивом
// function logError(err:string|string[]) {
//     if(Array.isArray(err)) return err.map(e=>{
//         console.log(e)
//     })
//     else console.log(err)
// }
//
// // таким образом можно сужать типы для юнион обьектов
// function logObject(obj:{a:number}|{b:number}) {
//     if('a'in obj) console.log(obj.a)
//     //будет показан вариант толкьо а, в случае else -только b
//     else console.log(obj.b)
// }
//
// function logMultipleIds(a:string|number,b:string|boolean) {
//     if(a===b)a.toUpperCase()
//     //в этом случае будет только строкой, поскольку только эти типы похожи в "а" и "b"
//
// }
//
//
//
// //********************************************************Литеральные типы***********************************
//  //********************************************************Литеральные типы***********************************/
//
// function fetchWithAuth(url:string,method:'post'|'get'): 1| -1 {
//    return -1
// }
// fetchWithAuth('http://localhost:8080','1')
//


//******************************type Aliases**********************************************************
//******************************type Aliases**********************************************************
//
// type httpMethod = 'post' | 'get';
//
// type coolString = string;
//
// function fetchWithAuth(url: string, method: httpMethod): 1 | -1 {
//     return -1
// }
//
// fetchWithAuth('http://localhost:8080', 'post')
//
//
// type User = {
//     name: string,
//     age: number,
//     skills: string[],
//     married: boolean
// }
//
// type Role = {
//     id: number;
// }
//
// //intersection
// type UserWithRole = User & Role
//
// let user: UserWithRole = {
//     name: 'asd',
//     age: 32,
//     skills: ['1', '2'],
//     married: false,
//     id: 3131313
// }


//******************************Interfaces**********************************************************
//******************************Interfaces**********************************************************
//******************************Interfaces**********************************************************
//кроме прочего интерфейсы нужно екстендить,  тайпы через амперсанд
// interface User {
//     name:string,
//     age:number,
//     skills:string[]
//
//     log:(id:number)=>string
// }
//
// interface Role {
//     roleId:number;
// }
//
// interface UserWithRole extends User,Role{
//     createdAt:Date;
// }
//
// let user:UserWithRole={
//     name:'test',
//     age:32,
//     roleId:1,
//     createdAt:new Date(),
//     skills:['skill 1','skill 2'],
//     log(id){
//         return '';
//     }
// }
//
// interface UserDictionary {
//     [index:number]:User
// }
//но в новой версии появился вариант - дженерик Record


//********************************Типы и Интерфейсы - разница*********************************
//********************************Типы и Интерфейсы - разница*********************************
//********************************Типы и Интерфейсы - разница*********************************


// interface User {
//     name:string
// }

//полезно использовать дополнение если используем какую то библиотеку , и нет возможности писать интерфейс с нуля
// и необходимо доопределить
// например в експрессе тип запоса реквест- взять его , докинуть какие то данные , доопределить
//Type не позвонил так сделать, это отличие тайпа от интерфейса
//Интерфейс нельзя заекстендить от примитивных типов. он позволяет работать с обьектами, с описанием классов
//но никак не с простыми типами
//---------------если подитожить- рекомендации по использованию
// -------------тайп единственный вариант использовать для примитивных типов
// -----------с обьектами всегда интерфейсы, чуть более удобные, так как можно переопределять библиотечные интерфейсы
// -----это ключевые различия
// type ID=string|number;
// interface ID1{
//     ID:string|number
// }
// interface User {
//     age:number
// }
//
// const User:User={
//     name:'2',
//     age:31
// }



// ***********************************Optional*****************************
// ***********************************Optional*****************************
// ***********************************Optional*****************************/

// interface User{
//     login:string,
//     password?:string;
// }
//
// const user:User={
//     login:'test'
// }
//
// function multiply (first:number,second?:number):number {
//     if(!second){
//         return first*first
//     }
//
//
//
//     return first*second
//     //в этом случае second или number или undefined, но можно сделать проверку и
//     //     будет работать только в случае number
//     // или же можно добавить дефолтное значение second:number=5
// }
//
// multiply(5)
//
// interface UserPro {
//     login:string;
//     password?:{
//         type:'primary'|'secondary'
//     }
// }
//
// function testPass(user:UserPro) {
//     const t=user.password?.type
//         // при получении типа от опционального значения, нужно спросить - есть ли он? если да , то делать проверку
//     const t1=user.password!.type
//     // знак ! даёт понимание что такое значение  100% будет,не будет undefined, берём ответственность на себя
//     //использовать редко, без лишней необоходимости не надо
//
// }
//
//
// function test1(param?:string) {
//     const t=param?? multiply(5)
//     // такое есть и в js и ts , если param null или undefined , то сработает фция multiply
//     //такая проверка удобна для короткой записи
// }
//
//






// ***********************************Void*****************************
// ***********************************Void*****************************

//     function logId(id:string|number):void {
//     console.log(id)
//
// }

// void говорит возвращай всё что угодно  , я просто буду это игнорировать, при работе с методами массивов итп
// типизируем функцию void когда хотим игнорировать возврат
//     в отличии от undefined, которая ждёт только undefined



// ***********************************Unknown****************************
// ***********************************Unknown*****************************
    //unknow - более строгий чем ANY, его нельзя положить в переменную с типом, пока мы сами его не определим,
    // можно его положить только в any
    // при сужении он будет unknow всегда, пока мы явно не проверим
    //в новом тс -ошибка стала unknow , и теперь нельзя обратиться к никакому свойства обьекта,
    // TS2571: Object is of type 'unknown'.
    //в отличнии от any

    // кейсы : с ошибком - где надо использовать явную проверку
    // кейсы : unknown использовать когда вход непонятен для вас, получаем его извне и юзаем вместо any
   //---- в больщинстве своём unknown для таких кейсов и нужен, когда хотим тип но не можем указать, по незнанию

//     async function getDataForce(){
//         try{
//
//         }catch (error) {
//             if(error instanceof Error){
//                 console.log(error.message)
//             }
//             // error.message - ошибка Object is of type 'unknown'.
//             // можно еще явно кастомнуть явно, но можно допустить промашку,еррор может прийти  строкой
//             // const e=error as Error
//         }
// }



// ***********************************Never****************************
// ***********************************Never*****************************
// позволяет описать кейсы где мы никогда не вернёмся
    function genereateError(message:string):never {
    throw new Error(message)
    }

    function dumpError():never {
        while (true){}
    }







// *********************************************************основы**********************************
// *********************************************************основы**********************************
// let revenue=1000;
// // let bonus='500';
// let bonus:number=500;
// let res:number=revenue+bonus
// // console.log(res)

// function getFullName(firstname:string,surname:string):string {
//     return `${firstname} ${surname}`;
// }

// const getFullNameArrow=(firstname:string,surname:string):string=>{
//     return `${firstname} ${surname}`;
// }
//
// function getFullName(userEntity:{firstname:string,surname:string}):string {
//     return `${userEntity.firstname} ${userEntity.surname}`;
// }
//


//*********************************************************arrays**********************************
//*********************************************************arrays**********************************
//*********************************************************arrays**********************************
//
// const skills:string[]=['DeV','devOps','TechLead'];
//
// // for(const skill of skills){
// //     console.log(skill.toLowerCase())
// // }
//
// const result=skills.filter((s:string)=>s!=='DevOps').map(s=>s+'! ').reduce((a,b)=>a+b)
// console.log(result)

//*********************************************************Tuples - кортежи**********************************
//*********************************************************Tuples - кортежи**********************************
//*********************************************************Tuples - кортежи**********************************
//с точки зрения js- это просто массив
// Кортежи удобны тем что можно ограничить его элементы, но  в него можно пушить , делать pop и тп
// const skill:[number,string]=[1,'Dev'];
// // const id=skill[0];
// // const skillName=skill[1];
// // const q=skill[2]
// const [id,skillName]=skill;
//
// const array:readonly [number,string,...boolean[]]=[1,'test',true,false];


//*********************************************************ENUMS**********************************
//*********************************************************ENUMS**********************************
//*********************************************************ENUMS**********************************
//енамы во многом себя ведут похоже на обьекты
//КЕЙСЫ - справочник кодов ответа, справочник величин, особенно физический (например влево вправо вверх вниз)
// еще КЕЙСЫ- параметр в базе- имеющий огр. число значение -  роли (админ, юзер, модер)
//
// function compute(){
//     return 3;
// }
// enum Roles{
//     ADMIN=1,
//     USER=ADMIN+1,
//     MODERATOR=compute(),
// }
// enum StatusCode{
//     SUCCESS=1,
//     IN_PROCESS,
//     FAILED,
// }
//
//
// //1 -успех
// //2 - в процессе
// //3 - отклонён
//
// const res={
//     message:'Платёж успешен',
//     statusCode:StatusCode.SUCCESS
// };
//
// //поведение енама как обьекта, таких кейсов мало или нету
// function test(x:{ADMIN:number}) {
//
// }
// test(Roles)
//
// const enum Roles1{
//     ADMIN=1,
//     USER=2
// }
//
// const admin=Roles1.ADMIN
//
const admin = 1 /* Roles1.ADMIN */
// так скомпилируется в jse